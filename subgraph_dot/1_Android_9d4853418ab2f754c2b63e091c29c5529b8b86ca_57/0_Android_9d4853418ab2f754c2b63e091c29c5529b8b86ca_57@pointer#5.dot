digraph "0_Android_9d4853418ab2f754c2b63e091c29c5529b8b86ca_57@pointer" {
"1000219" [label="(Call,that->greenf = that->redf)"];
"1000127" [label="(Call,sample_scale(that->redf, scale))"];
"1000112" [label="(Call,scale = (1U<<that->sample_depth)-1)"];
"1000114" [label="(Call,(1U<<that->sample_depth)-1)"];
"1000115" [label="(Call,1U<<that->sample_depth)"];
"1000215" [label="(Call,that->bluef = that->greenf = that->redf)"];
"1000116" [label="(Literal,1U)"];
"1000254" [label="(Call,sample_scale(that->alphaf, scale))"];
"1000114" [label="(Call,(1U<<that->sample_depth)-1)"];
"1000128" [label="(Call,that->redf)"];
"1000291" [label="(MethodReturn,RET)"];
"1000220" [label="(Call,that->greenf)"];
"1000203" [label="(Block,)"];
"1000115" [label="(Call,1U<<that->sample_depth)"];
"1000120" [label="(Literal,1)"];
"1000110" [label="(Block,)"];
"1000219" [label="(Call,that->greenf = that->redf)"];
"1000127" [label="(Call,sample_scale(that->redf, scale))"];
"1000117" [label="(Call,that->sample_depth)"];
"1000121" [label="(Call,(display)\n\n /* At the end recalculate the digitized red green and blue values according\n    * to the current sample_depth of the pixel.\n    *\n    * The sample value is simply scaled to the maximum, checking for over\n    * and underflow (which can both happen for some image transforms,\n    * including simple size scaling, though libpng doesn't do that at present.\n\n     */\n    that->red = sample_scale(that->redf, scale))"];
"1000112" [label="(Call,scale = (1U<<that->sample_depth)-1)"];
"1000215" [label="(Call,that->bluef = that->greenf = that->redf)"];
"1000158" [label="(Call,sample_scale(that->greenf, scale))"];
"1000228" [label="(Identifier,that)"];
"1000113" [label="(Identifier,scale)"];
"1000223" [label="(Call,that->redf)"];
"1000216" [label="(Call,that->bluef)"];
"1000131" [label="(Identifier,scale)"];
"1000276" [label="(Call,that->alpha = scale)"];
"1000219" -> "1000215"  [label="AST: "];
"1000219" -> "1000223"  [label="CFG: "];
"1000220" -> "1000219"  [label="AST: "];
"1000223" -> "1000219"  [label="AST: "];
"1000215" -> "1000219"  [label="CFG: "];
"1000219" -> "1000291"  [label="DDG: that->redf"];
"1000219" -> "1000291"  [label="DDG: that->greenf"];
"1000219" -> "1000215"  [label="DDG: that->greenf"];
"1000127" -> "1000219"  [label="DDG: that->redf"];
"1000127" -> "1000121"  [label="AST: "];
"1000127" -> "1000131"  [label="CFG: "];
"1000128" -> "1000127"  [label="AST: "];
"1000131" -> "1000127"  [label="AST: "];
"1000121" -> "1000127"  [label="CFG: "];
"1000127" -> "1000291"  [label="DDG: that->redf"];
"1000127" -> "1000121"  [label="DDG: that->redf"];
"1000127" -> "1000121"  [label="DDG: scale"];
"1000112" -> "1000127"  [label="DDG: scale"];
"1000127" -> "1000158"  [label="DDG: scale"];
"1000127" -> "1000215"  [label="DDG: that->redf"];
"1000127" -> "1000254"  [label="DDG: scale"];
"1000127" -> "1000276"  [label="DDG: scale"];
"1000112" -> "1000110"  [label="AST: "];
"1000112" -> "1000114"  [label="CFG: "];
"1000113" -> "1000112"  [label="AST: "];
"1000114" -> "1000112"  [label="AST: "];
"1000123" -> "1000112"  [label="CFG: "];
"1000112" -> "1000291"  [label="DDG: (1U<<that->sample_depth)-1"];
"1000114" -> "1000112"  [label="DDG: 1U<<that->sample_depth"];
"1000114" -> "1000112"  [label="DDG: 1"];
"1000114" -> "1000120"  [label="CFG: "];
"1000115" -> "1000114"  [label="AST: "];
"1000120" -> "1000114"  [label="AST: "];
"1000114" -> "1000291"  [label="DDG: 1U<<that->sample_depth"];
"1000115" -> "1000114"  [label="DDG: 1U"];
"1000115" -> "1000114"  [label="DDG: that->sample_depth"];
"1000115" -> "1000117"  [label="CFG: "];
"1000116" -> "1000115"  [label="AST: "];
"1000117" -> "1000115"  [label="AST: "];
"1000120" -> "1000115"  [label="CFG: "];
"1000115" -> "1000291"  [label="DDG: that->sample_depth"];
"1000215" -> "1000203"  [label="AST: "];
"1000216" -> "1000215"  [label="AST: "];
"1000228" -> "1000215"  [label="CFG: "];
"1000215" -> "1000291"  [label="DDG: that->bluef"];
}
